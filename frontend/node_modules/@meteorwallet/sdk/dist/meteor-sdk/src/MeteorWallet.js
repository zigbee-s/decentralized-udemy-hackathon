"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectedMeteorWalletAccount = exports.MeteorWallet = void 0;
const near_api_js_1 = require("near-api-js");
// import { Action, createTransaction, Transaction } from "near-api-js/lib/transaction";
const ExternalActionTypes_1 = require("../../meteor-common/src/models/external_actions/ExternalActionTypes");
const borsh_1 = require("borsh");
const StringUtils_1 = require("../../meteor-common/src/utils/StringUtils");
// import { PublicKey } from "near-api-js/lib/utils";
const EnvironmentStorageUtils_1 = require("../../meteor-common/src/utils/EnvironmentStorageUtils");
const TransactionSchema_1 = require("./near-schema/TransactionSchema");
const MeteorSdkUtils_1 = require("./utils/MeteorSdkUtils");
const MeteorPostMessenger_1 = require("./postMessage/MeteorPostMessenger");
const LOGIN_WALLET_URL_SUFFIX = "/login/";
const SIGN_WALLET_URL_SUFFIX = "/sign/";
const MULTISIG_HAS_METHOD = "add_request_and_confirm";
const LOCAL_STORAGE_KEY_SUFFIX = "_meteor_wallet_auth_key";
const PENDING_ACCESS_KEY_PREFIX = "pending_key"; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)
const localStorageAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({
    getString: (key) => window.localStorage.getItem(key),
    setString: (key, value) => window.localStorage.setItem(key, value),
    clear: (key) => window.localStorage.removeItem(key),
});
const sessionAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({
    getString: (key) => window.sessionStorage.getItem(key),
    setString: (key, value) => window.sessionStorage.setItem(key, value),
    clear: (key) => window.sessionStorage.removeItem(key),
});
/**
 * This class is used in conjunction with `near-api-js` and `BrowserLocalStorageKeyStore`.
 * It directs users to the Meteor Extension or (if not available) a popup of the Meteor Wallet website for key management.
 *
 * @example
 * ```js
 * import { MeteorWallet } from "@meteorwallet/sdk";
 *
 * // create new MeteorWallet instance (passing in your initialized Near connection)
 * const meteorWallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });
 *
 * // -- or -- (for a quick and default Near connection config)
 * const meteorWallet = MeteorWallet.init({ networkId: "testnet" });
 *
 * // If not signed in, start the sign-in flow with Meteor Wallet.
 * // Keys will be stored in the BrowserLocalStorageKeyStore
 * if(!meteorWallet.isSignedIn()) {
 *   const { accountId } = await meteorWallet.requestSignIn();
 * }
 * ```
 */
class MeteorWallet {
    /**
     * Construct MeteorWallet. If you'd a quick and default way, you can also use {@link MeteorWallet.init}
     *
     * @example
     * ```js
     * // create new MeteorWallet instance (passing in your initialized Near connection)
     * const meteorWallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });
     *
     * if(!meteorWallet.isSignedIn()) {
     *   const { accountId } = await meteorWallet.requestSignIn();
     * }
     * ```
     */
    constructor(_a) {
        var _b, _c;
        var { near, appKeyPrefix = (_b = near.config.contractName) !== null && _b !== void 0 ? _b : "default" } = _a;
        /** @hidden */
        this._initializationPromises = [];
        this._near = near;
        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;
        this._authDataKey = authDataKey;
        this._authData = (_c = localStorageAdapter.getJson(authDataKey)) !== null && _c !== void 0 ? _c : { allKeys: [] };
        this._networkId = near.config.networkId;
        this._walletBaseUrl = near.config.walletUrl;
        this._keyStore = near.connection.signer.keyStore;
        /*
        console.log("Initialized wallet- checking if signed in");
    
        if (!this.isSignedIn()) {
          console.log("Completing sign-in process, if its available");
          this._initializationPromises.push(this._completeSignInWithAccessKey());
        }*/
    }
    /**
     * The easiest way to set up the SDK. Returns an instance of MeteorWallet, automatically connected to the Near API.
     *
     * If you need more control over the Near Network configuration- rather use {@link MeteorWallet:constructor}
     *
     * @example
     * ```js
     * const wallet = await MeteorWallet.init({ networkId: "testnet" });
     * ```
     */
    static async init({ walletUrl, ...config }) {
        const keyStore = new near_api_js_1.keyStores.BrowserLocalStorageKeyStore();
        const near = await (0, near_api_js_1.connect)({
            keyStore,
            headers: {},
            walletUrl: (0, MeteorSdkUtils_1.resolveWalletUrl)(config.networkId, walletUrl),
            ...(0, MeteorSdkUtils_1.getNetworkPreset)(config.networkId),
            ...config,
        });
        const wallet = new MeteorWallet({ near, appKeyPrefix: "near_app" });
        // Cleanup up any pending keys (cancelled logins).
        if (!wallet.isSignedIn()) {
            await keyStore.clear();
        }
        return wallet;
    }
    /* async initialize() {
       await Promise.all(this._initializationPromises);
     }*/
    isExtensionInstalled() {
        return window.meteorWallet != null;
    }
    /**
     * Returns true, if this app is authorized with an account in the wallet.
     * @example
     * ```js
     * const wallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });
     * wallet.isSignedIn();
     * ```
     */
    isSignedIn() {
        return !!this._authData.accountId;
    }
    /**
     * Returns authorized Account ID.
     * @example
     * ```js
     * const wallet = new MeteorWallet(near, 'my-app');
     * const accountId = wallet.getAccountId();
     * ```
     */
    getAccountId() {
        return this._authData.accountId;
    }
    /**
     * Verifies that the user is the owner of a specific Near account, available in the wallet.
     * Removes the need to do blockchain operations for simple Dapp actions.
     * Signs a payload with the wallet's private key. Will return a promise with a payload like so:
     *
     * ```ts
     * interface VerifiedOwner {
     *   accountId: string;
     *   message: string;                 // The same passed message, unencrypted
     *   blockId: string;
     *   publicKey: string;               // The public key which should be verified as belonging to this account
     *   signature: string;               // The signed payload (this exact same object JSON stringified, excluding this "signature" property)
     *   keyType: utils.key_pair.KeyType; // Type from inside the near-api-js package
     * }
     * ```
     *
     * or throw a {@link MeteorActionError} error if the verification failed for whatever reason.
     * */
    async verifyOwner(options) {
        var _a;
        const accountId = (_a = options.accountId) !== null && _a !== void 0 ? _a : this.getAccountId();
        const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
            actionType: ExternalActionTypes_1.EWalletExternalActionType.verify_owner,
            inputs: {
                accountId,
                message: options.message,
            },
            network: this._networkId,
        });
        if (response.success) {
            return response;
        }
        else {
            throw new ExternalActionTypes_1.MeteorActionError({
                endTags: response.endTags,
                message: response.message,
            });
        }
    }
    /**
     * Requests a sign-in using Meteor Wallet. Will return a promise with the `accountId` of the
     * signed-in account, or throw a {@link MeteorActionError} error if the sign-in failed for whatever reason.
     * */
    async requestSignIn(options) {
        const { keyPair, ...restOptions } = options;
        const accessKey = keyPair !== null && keyPair !== void 0 ? keyPair : near_api_js_1.KeyPair.fromRandom("ed25519");
        let usingPublicKey = accessKey.getPublicKey().toString();
        const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
            actionType: ExternalActionTypes_1.EWalletExternalActionType.login,
            inputs: { public_key: usingPublicKey, ...restOptions },
            network: this._networkId,
        });
        if (response.success) {
            const { allKeys, accountId } = response.payload;
            this._authData = {
                accountId,
                allKeys,
                signedInContract: {
                    contract_id: restOptions.contract_id,
                    public_key: usingPublicKey,
                },
            };
            localStorageAdapter.setJson(this._authDataKey, this._authData);
            await this._keyStore.setKey(this._networkId, accountId, accessKey);
            return {
                success: true,
                endTags: [],
                payload: {
                    accessKey,
                    accountId,
                },
            };
        }
        else {
            throw new ExternalActionTypes_1.MeteorActionError({
                endTags: response.endTags,
                message: response.message,
            });
        }
    }
    /**
     * Sign out from the current account
     */
    async signOut() {
        const accountId = this.getAccountId();
        if (this._authData.signedInContract != null && accountId != null) {
            const inputs = {
                accountId,
                contractInfo: this._authData.signedInContract,
            };
            const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
                actionType: ExternalActionTypes_1.EWalletExternalActionType.logout,
                inputs,
                network: this._networkId,
            });
        }
        this._authData = { allKeys: [] };
        localStorageAdapter.clear(this._authDataKey);
    }
    /**
     * Sign transactions using Meteor Wallet. Will return a promise with an array of `FinalExecutionOutcome`
     * of the given transactions.
     * */
    async requestSignTransactions(inputs) {
        const { transactions } = inputs;
        const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
            actionType: ExternalActionTypes_1.EWalletExternalActionType.sign,
            inputs: {
                transactions: transactions
                    .map((transaction) => (0, borsh_1.serialize)(TransactionSchema_1.SCHEMA, transaction))
                    .map((serialized) => Buffer.from(serialized).toString("base64"))
                    .join(","),
            },
            // inputs: { public_key: usingPublicKey, ...options },
            network: this._networkId,
        });
        // console.log("Finished sign-in request", response);
        if (response.success) {
            return response.payload.executionOutcomes;
        }
        else {
            throw new ExternalActionTypes_1.MeteorActionError({
                endTags: response.endTags,
                message: response.message,
            });
        }
        return [];
    }
    /**
     * Returns the current connected wallet account
     */
    account() {
        const currentAccountId = this.getAccountId();
        if (!this._connectedAccount && (0, StringUtils_1.notNullEmpty)(currentAccountId)) {
            this._connectedAccount = new ConnectedMeteorWalletAccount(this, this._near.connection, currentAccountId);
        }
        return this._connectedAccount;
    }
}
exports.MeteorWallet = MeteorWallet;
/**
 * Near Account implementation which makes use of {@link MeteorWallet} when no local key is available.
 *
 * Generally won't be created directly- can be obtained by using {@link MeteorWallet.account}
 *
 * @example
 * ```js
 * const account = meteorWallet.account();
 *
 * // uses Meteor Wallet to sign the transaction using this account
 * const response = await account.requestSignTransaction({
 *   actions: transactionActions,
 *   receiverId: "my-contract"
 * });
 * ```
 */
class ConnectedMeteorWalletAccount extends near_api_js_1.Account {
    /** @hidden */
    constructor(walletConnection, connection, accountId) {
        super(connection, accountId);
        this.meteorWallet = walletConnection;
    }
    /**
     * Sign a transaction using Meteor Wallet. Overrides the Near Account API method of the same name, makes use of {@link ConnectedMeteorWalletAccount.signAndSendTransaction_direct}
     */
    async signAndSendTransaction(...args) {
        if (typeof args[0] === "string") {
            return this.signAndSendTransaction_direct({ receiverId: args[0], actions: args[1] });
        }
        return this.signAndSendTransaction_direct(args[0]);
    }
    /** @hidden */
    async trySendOrCreateTransaction({ receiverId, actions, }) {
        const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
        let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);
        if (!accessKey) {
            throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);
        }
        if (localKey && localKey.toString() === accessKey.public_key) {
            try {
                return { executionOutcome: await super.signAndSendTransaction({ receiverId, actions }), sent: true };
            }
            catch (e) {
                if (e.type === "NotEnoughAllowance") {
                    accessKey = await this.accessKeyForTransaction(receiverId, actions);
                }
                else {
                    throw e;
                }
            }
        }
        const block = await this.connection.provider.block({ finality: "final" });
        const blockHash = (0, borsh_1.baseDecode)(block.header.hash);
        const publicKey = near_api_js_1.utils.PublicKey.from(accessKey.public_key);
        // TODO: Cache & listen for nonce updates for given access key
        const nonce = accessKey.access_key.nonce + 1;
        const transaction = near_api_js_1.transactions.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);
        return {
            sent: false,
            transaction,
        };
    }
    /**
     * Sign a transaction using Meteor Wallet
     * @see {@link MeteorWallet.requestSignTransactions}
     */
    async signAndSendTransaction_direct({ receiverId, actions, }) {
        const { transaction, sent, executionOutcome } = await this.trySendOrCreateTransaction({ receiverId, actions });
        if (sent) {
            return executionOutcome;
        }
        return (await this.meteorWallet.requestSignTransactions({ transactions: [transaction] }))[0];
    }
    /** @hidden */
    /*async signAndSendTransaction_redirect({
      receiverId,
      actions,
      walletMeta,
      walletCallbackUrl = window.location.href,
    }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome> {
      const { transaction, sent, executionOutcome } = await this.trySendOrCreateTransaction({ receiverId, actions });
  
      if (sent) {
        return executionOutcome!;
      }
  
      await this.meteorWallet.requestSignTransactions_redirect({
        transactions: [transaction!],
        meta: walletMeta,
        callback_url: walletCallbackUrl,
      });
  
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          reject(new Error("Failed to redirect to sign transaction"));
        }, 1000);
      });
    }*/
    /**
     * Check if given access key allows the function call or method attempted in transaction
     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items
     * @param receiverId The NEAR account attempting to have access
     * @param actions The action(s) needed to be checked for access
     */
    async accessKeyMatchesTransaction(accessKey, receiverId, actions) {
        const { access_key: { permission }, } = accessKey;
        if (permission === "FullAccess") {
            return true;
        }
        if (permission.FunctionCall) {
            const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;
            /********************************
             Accept multisig access keys and let wallets attempt to signAndSendTransaction
             If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153
             ********************************/
            if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {
                return true;
            }
            if (allowedReceiverId === receiverId) {
                if (actions.length !== 1) {
                    return false;
                }
                const [{ functionCall }] = actions;
                return (functionCall &&
                    (!functionCall.deposit || functionCall.deposit.toString() === "0") && // TODO: Should support charging amount smaller than allowance?
                    (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName)));
                // TODO: Handle cases when allowance doesn't have enough to pay for gas
            }
        }
        // TODO: Support other permissions than FunctionCall
        return false;
    }
    /**
     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission
     * @param receiverId The NEAR account seeking the access key for a transaction
     * @param actions The action(s) sought to gain access to
     * @param localKey A local public key provided to check for access
     * @returns Promise<any>
     */
    async accessKeyForTransaction(receiverId, actions, localKey) {
        const accessKeys = await this.getAccessKeys();
        if (localKey) {
            const accessKey = accessKeys.find((key) => key.public_key.toString() === localKey.toString());
            if (accessKey && (await this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {
                return accessKey;
            }
        }
        const walletKeys = this.meteorWallet._authData.allKeys;
        for (const accessKey of accessKeys) {
            if (walletKeys.indexOf(accessKey.public_key) !== -1 &&
                (await this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {
                return accessKey;
            }
        }
        return null;
    }
}
exports.ConnectedMeteorWalletAccount = ConnectedMeteorWalletAccount;
//# sourceMappingURL=MeteorWallet.js.map